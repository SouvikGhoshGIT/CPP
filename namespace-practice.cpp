/*
1.Namespace is a feature added in C++ and not present in C.
A namespace is a declarative region that provides a scope to the identifiers (names of the types, function, variables etc) inside it.
Multiple namespace blocks with the same name are allowed. All declarations within those blocks are declared in the named scope.


Namespace declarations appear only at global scope.
Namespace declarations can be nested within another namespace.
Namespace declarations don’t have access specifiers. (Public or private)
No need to give semicolon after the closing brace of definition of namespace.
We can split the definition of namespace over several units.

In C++, there are two ways of accessing namespace variables and functions.
1.using scope resolution operator ::

2.using "using" directive 
using namespace geek; 

3.Another unconventional way is below
We can create namespace in one file and access contents using another program. This is done in the following manner.
We need to create two files. One containing the namespace and all the data members and member functions we want to use later.
And the other program can directly call the first program to use all the data members and member functions in it.


*/
#include<iostream>
using namespace std;

int val=100;

namespace first{
    int val=200;
    void calc(){
        std::cout << val*5 << "\n";
    }
}

namespace ns2{
     int val=100;
    void calc(){
        std::cout << val*5 << "\n";
    }
}

namespace func{
    class obj{
        public:
            void show(){
                std::cout << "Printing from func namespace \n";
            }
    };

    class obj2;

    class obj3{

        public:
        void show3();

    };
};

//We can define methods also outside the namespace
void func::obj3::show3(){
    std::cout << "We can define methods also outside the namespace. \n" ;
        };


//Class can also be declared inside namespace and defined outside namespace
class func::obj2{

    public:
        void show1(){
            std::cout << "Class can also be declared inside namespace and defined outside namespace \n" ;
        }
};


/*

Unnamed Namespaces

They are directly usable in the same program and are used for declaring unique identifiers.
In unnamed namespaces, name of the namespace in not mentioned in the declaration of namespace.
The name of the namespace is uniquely generated by the compiler.
The unnamed namespaces you have created will only be accessible within the file you created it in.
Unnamed namespaces are the replacement for the static declaration of variables.



*/

namespace {
    int rel=1000;
}

//nested namespace

namespace L1{
    namespace L2{
        namespace L3{
            int val=456;
        }
    }
}


/*

Why “using namespace std” is considered bad practice:

The statement using namespace std is generally considered bad practice. The alternative to this statement is to specify the namespace to which the identifier belongs using the scope operator(::) each time we declare a type.
Consider using typedefs 
typedefs save us from writing long type definitions. In our example 1, we could solve the problem using two typedefs one for std library and another for foo

filter_none
brightness_4
#include <foo> 
#include <iostream> 
  
typedef std::cout cout_std; 
typedef foo::cout cout_foo; 
  
cout_std << "Something to write"; 
cout_foo << "Something to write"; 


If you still import entire namespaces, try to do so inside functions or limited scope and not in global scope.
*/


//Inline namespaces
namespace nms{
    inline namespace nms_inline{
        /*
        An inline namespace is a namespace that uses the optional keyword inline in its original-namespace-definition.
        members of an inline namespace are treated as if they are members of the enclosing namespace in many situations (listed below). This property is transitive: if a namespace N contains an inline namespace M, which in turn contains an inline namespace O, then the members of O can be used as though they were members of M or N.
        Inline namespace
The inline namespace mechanism is intended to support library evolution by providing a mechanism that support a form of versioning. Consider:

	// file V99.h:
	inline namespace V99 {
		void f(int);	// does something better than the V98 version
		void f(double);	// new feature
		// ...
	}

	// file V98.h:
	namespace V98 {
		void f(int);	// does something
		// ...
	}

	// file Mine.h:
	namespace Mine {
	#include "V99.h"
	#include "V98.h"
	}
We here have a namespace Mine with both the latest release (V99) and the previous one (V98). If you want to be specific, you can:

	#include "Mine.h"
	using namespace Mine;
	// ...
	V98::f(1);	// old version
	V99::f(1);	// new version
	f(1);		// default version



    This same behavior (same as inline namesapces) can also be achieved by using the "using" declarative inside namespaces. A using-directive that names the inline namespace is implicitly inserted in the enclosing namespace (similar to the implicit using-directive for the unnamed namespace). Consider the following C++ code:

filter_none
edit
play_arrow

brightness_4
// C++ program to demonstrate working 
// of "using" to get the same effect as 
// inline. 
#include <iostream> 
using namespace std; 
  
namespace ns1 
{ 
    namespace ns2 
    { 
        namespace ns3 
        { 
            int var = 10; 
        } 
        using namespace ns3; 
    } 
      
    using namespace ns2; 
} 
  
int main() 
{ 
    cout << ns1::var; 
    return 0; 
} 
        */
        void show(){
            cout << "speaking from inline namespace \n" ;
        }
    }
}

int main(){
    cout << val <<"\n";
    cout << first::val << "\n";
    first::calc();
    ns2::calc();
    func::obj obj;
    obj.show();
    func::obj2 objw;
    objw.show1();
    func::obj3 onj3;
    onj3.show3();
    cout << rel <<"\n";
    cout << L1::L2::L3::val << "\n";
    namespace alias=L1::L2::L3;
    cout << alias::val <<"\n" ;
    nms::show();

    

}